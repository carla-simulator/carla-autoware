#!/usr/bin/env python
#
# Copyright (c) 2019 Intel Corporation
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.
#
import rospy
import carla

import tf
import math
import threading

from agents.navigation.local_planner import compute_connection, RoadOption

from autoware_msgs.msg import LaneArray
from autoware_msgs.msg import Lane
from autoware_msgs.msg import Waypoint
from geometry_msgs.msg import PoseWithCovarianceStamped
from geometry_msgs.msg import PoseStamped
from tf.transformations import euler_from_quaternion,quaternion_from_euler

class CarlaToAutowareWaypointConverter(object):
    """
    This class generates a plan of waypoints to follow.
    
    The calculation is done whenever:
    - the hero vehicle appears
    - a new goal is set
    """
    WAYPOINT_DISTANCE = 2.0
    
    def __init__(self, carla_world):
        self.world = carla_world
        self.map = carla_world.get_map()
        self.ego_vehicle = None
        self.waypoint_publisher = rospy.Publisher('/lane_waypoints_array', LaneArray, queue_size=10, latch=True)

        #set initial goal
        self.goal = self.world.get_map().get_spawn_points()[0]
        
        self.current_route = None
        self.goal_subscriber = rospy.Subscriber("/move_base_simple/goal", PoseStamped, self.on_goal)
        
        self._update_lock = threading.Lock()
        
        #use callback to wait for ego vehicle
        rospy.loginfo("Waiting for ego vehicle...")
        self.world.on_tick(self.find_ego_vehicle_actor)

    def on_goal(self, goal):
        """
        Callback for /move_base_simple/goal

        Receiving a goal (e.g. from RVIZ '2D Nav Goal') triggers a new route calculation.

        :return:
        """
        carla_goal = carla.Transform()
        carla_goal.location.x = goal.pose.position.x
        carla_goal.location.y = -goal.pose.position.y
        carla_goal.location.z = goal.pose.position.z + 2 # 2m above ground
        quaternion = (
            goal.pose.orientation.x,
            goal.pose.orientation.y,
            goal.pose.orientation.z,
            goal.pose.orientation.w
        )
        roll,pitch,yaw = euler_from_quaternion(quaternion)
        carla_goal.rotation.yaw = -math.degrees(yaw)

        self.goal = carla_goal
        self.reroute()

    def reroute(self):
        if self.ego_vehicle is None or self.goal is None:
            #no ego vehicle, remove route if published
            self.current_route = None
            self.publish_waypoints()
        else:
            self.current_route = self.calculate_route(self.goal)
        self.publish_waypoints()

    def find_ego_vehicle_actor(self, carla_timestamp):
        with self._update_lock:
            hero = None
            for actor in self.world.get_actors():
                if (actor.attributes.get('role_name') == "ego_vehicle"):
                    hero = actor
                    break

            ego_vehicle_changed = False
            if hero is None and self.ego_vehicle is not None:
                ego_vehicle_changed = True

            if not ego_vehicle_changed and hero is not None and self.ego_vehicle is None:
                ego_vehicle_changed = True

            if not ego_vehicle_changed and hero is not None and self.ego_vehicle is not None and hero.id != self.ego_vehicle.id:
                ego_vehicle_changed = True

            if ego_vehicle_changed:
                rospy.loginfo("Ego vehicle changed.")
                self.ego_vehicle = hero
                self.reroute()
        

    def calculate_route(self, goal):
        """
        This function is based on basic_planner.set_destination()
        """
        rospy.loginfo("Calculating route to x={}, y={}, z={}".format(
                           goal.location.x,
                           goal.location.y,
                           goal.location.z))
        start_waypoint = self.map.get_waypoint(self.ego_vehicle.get_location())
        end_waypoint = self.map.get_waypoint(carla.Location(goal.location.x,
                                                             goal.location.y,
                                                             goal.location.z))
  
        current_waypoint = start_waypoint
        active_list = [ [(current_waypoint, RoadOption.LANEFOLLOW)] ]
  
        solution = []
        while not solution:
            for _ in range(len(active_list)):
                trajectory = active_list.pop()
                if len(trajectory) > 1000:
                    continue
  
                # expand this trajectory
                current_waypoint, _ = trajectory[-1]
                next_waypoints = current_waypoint.next(self.WAYPOINT_DISTANCE)
                while len(next_waypoints) == 1:
                    next_option = compute_connection(current_waypoint, next_waypoints[0])
                    current_distance = next_waypoints[0].transform.location.distance(end_waypoint.transform.location)
                    if current_distance < self.WAYPOINT_DISTANCE:
                        solution = trajectory + [(end_waypoint, RoadOption.LANEFOLLOW)]
                        break
  
                    # keep adding nodes
                    trajectory.append((next_waypoints[0], next_option))
                    current_waypoint, _ = trajectory[-1]
                    next_waypoints = current_waypoint.next(self.WAYPOINT_DISTANCE)
  
                if not solution:
                    # multiple choices
                    for waypoint in next_waypoints:
                        next_option = compute_connection(current_waypoint, waypoint)
                        active_list.append(trajectory + [(waypoint, next_option)])
  
        assert solution
        return solution
  
 
    def publish_waypoints(self):
        msg = LaneArray()
        lane = Lane()
        lane.header.frame_id = "/map"
        msg.lanes.append(lane)
        if self.current_route is not None:
            for wp in self.current_route:
                waypoint = Waypoint()
                waypoint.pose.pose.position.x = wp[0].transform.location.x
                waypoint.pose.pose.position.y = -wp[0].transform.location.y
                waypoint.pose.pose.position.z = wp[0].transform.location.z
    
                quaternion = tf.transformations.quaternion_from_euler(0, 0, -math.radians(wp[0].transform.rotation.yaw))
                waypoint.pose.pose.orientation.x = quaternion[0]
                waypoint.pose.pose.orientation.y = quaternion[1]
                waypoint.pose.pose.orientation.z = quaternion[2]
                waypoint.pose.pose.orientation.w = quaternion[3]
                msg.lanes[0].waypoints.append(waypoint)
                #file format for autoware waypoint loader:
                #print("{},{},{},{},0,0\n".format(wp[0].transform.location.x,-wp[0].transform.location.y,38.1,math.radians(wp[0].transform.rotation.yaw)))

        self.waypoint_publisher.publish(msg)
        rospy.loginfo("Published {} waypoints.".format(len(msg.lanes[0].waypoints)))


def main():

    rospy.init_node("carla_waypoint_publisher", anonymous=True)

    host = rospy.get_param("/carla/host", "127.0.0.1")
    port = rospy.get_param("/carla/port", 2000)

    rospy.loginfo("Trying to connect to {host}:{port}".format(
        host=host, port=port))

    try:
        carla_client = carla.Client(host=host, port=port)
        carla_client.set_timeout(2)

        carla_world = carla_client.get_world()
        
        rospy.loginfo("Connected to Carla.")

        waypointConverter = CarlaToAutowareWaypointConverter(carla_world)

        rospy.spin()
        del waypointConverter
        del carla_world
        del carla_client

    finally:
        rospy.loginfo("Done")

if __name__ == "__main__":
    main()
